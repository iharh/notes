2021
https://www.tecmint.com/10-lsof-command-examples-in-linux/
https://bookflow.ru/10-primerov-komand-lsof-v-linux/

*************************************************************************************************
Утилиту lsof в дистрибутивах Linux чаще всего используют для просмотра открытых файлов. Я и сам так делаю, и много материалов на эту тему видел. Да и название у неё говорящее. Оно как раз образовано от фразы list open files.
Тем не менее, её можно использовать не только для этого. 

▪️ Но сначала про основную функциональность. Лично я чаще всего запускаю lsof для просмотра открытых файлов, которые удалили, но забыли закрыть файловый дескриптор. Например, наживую удалили лог nginx или docker и не перезапустили сервис. В итоге файла нет, а место он занимает. Такие файлы будет видно вот так:
# lsof | grep '(deleted)'
или так:
# lsof +L1

▪️ Смотрим кем и что конкретно открыто из файлов в указанной директории:
# lsof +D /var/log

▪️ Смотрим открытые файлы конкретного пользователя:
# lsof -u user
Часто бывает нужно быстро узнать, сколько файлов у него открыто, чтобы понять, если с ним проблема или нет:
# lsof -u user | wc -l
А теперь то же самое, только наоборот исключим открытые файлы пользователя:
# lsof -u^user | wc -l
Рассмотрим ситуацию, когда под пользователем плодятся процессы, которые открывают кучу файлов и нам всё это надо быстро прибить. Добавляем ключ -t к lsof, который позволяет выводить только PID процессов. И отправляем вывод в kill:
# kill -9 `lsof -t -u user`

▪️ Файлы, открытые конкретным процессом, для которого указан его PID. Очень востребованная функциональность.
# lsof -p 94169

▪️ А теперь немного того, что от lsof не ожидаешь. Список TCP соединений, причём очень наглядный и удобный для восприятия.
# lsof -ni

▪️ Смотрим подробную информацию о том, кто открыл 80-й порт:
# lsof -ni TCP:80  

▪️ Список TCP соединений к конкретному IP адресу:
# lsof -ni TCP@172.29.139.228

▪️ Список TCP соединений конкретного пользователя:
# lsof -ai -u nginx

▪️ Помимо TCP, можно и UDP соединения смотреть:
# lsof -iUDP

Публикацию имеет смысл сохранить в закладки.

***************************************************************************************************************************************************************************

Как быстро прибить приложение, которое слушает определённый порт?

Вариантов решения этой задачи может быть много. Первое, что приходит в голову - посмотреть список открытых портов в ss, узнать pid процесса и завершить его:

# ss -tulnp | grep 8080
tcp LISTEN 0 5 0.0.0.0:8080 0.0.0.0:* users:(("python3",pid=5152,fd=3))
# kill 5152

Но быстрее и проще воспользоваться lsof:

# lsof -i:8080
COMMAND PID USER  FD  TYPE DEVICE SIZE/OFF NODE NAME
python3 5156 root  3u IPv4 41738   0t0 TCP *:http-alt (LISTEN)
# kill 5152

Или вообще в одно действие:

# lsof -i:8080 -t | xargs kill

Lsof могучая утилита. Я как-то особо не пользовался ей, кроме как для файлов, пока не подготовил заметку год назад с примерами использования (https://t.me/srv_admin/2856). С тех порт и для сетевых соединений стал активно применять. Особенно вот в таком виде:

# lsof -i
# lsof -i TCP:25
# lsof -i TCP@1.2.3.4

Возвращаюсь к открытым портам. Есть утилита killport (https://github.com/jkfran/killport), которая делает то же самое, что я делал выше, только в одну команду:

# killport 8080

В стандартных репах её нет, придётся качать бинарник из репозитория. Если для Linux это не сильно надо, так как там много инструментов для подобных действий, что я продемонстрировал выше, то для Windows это будет более актуально. Killport есть и под винду (❗️) Использовать можно примерно так:

> killport 445 --dry-run
Would kill process 'System' listening on port 445

То есть сначала смотрим, что будет прибито, а потом только делаем. 

Такая штука обычно нужна для каких-то костылей и велосипедов, когда что-то зависает, не перезапускается, а надо освободить порт, чтобы запустить новый экземпляр.
