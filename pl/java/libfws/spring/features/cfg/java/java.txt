https://projects.spring.io/spring-framework/

https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java
https://docs.spring.io/spring-boot/docs/2.0.0.M7/reference/htmlsingle/#boot-features-developing-auto-configuration

http://www.baeldung.com/spring-boot-migration

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

@Conditional
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-conditional

ConditionalOnClass
ConditionalOnProperty
ConditionalOnMissingBean


https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-docs/src/main/asciidoc/spring-boot-features.adoc#web-environment
Web Environment:
A SpringApplication attempts to create the right type of ApplicationContext on your behalf. By default, an AnnotationConfigApplicationContext or
AnnotationConfigServletWebServerApplicationContext is used, depending on whether you are developing a web application or not.

https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader/src/it/executable-props-lib/src/main/java/org/springframework/boot/launcher/it/props/EmbeddedJarStarter.java

cheat-sheets:
https://zeroturnaround.com/rebellabs/spring-framework-annotations-cheat-sheet/
http://files.zeroturnaround.com/pdf/zt_spring_annotations_cheat_sheet.pdf

public final class EmbeddedJarStarter {
    public static void main(String[] args) throws Exception {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfiguration.class);
        context.getBean(SpringConfiguration.class).run(args);
        context.close();
    }
}

-//-/SpringConfiguration.java
@Configuration
@ComponentScan
public class SpringConfiguration implements InitializingBean {
    private String message = "Jar";
    @Override
    public void afterPropertiesSet() throws IOException {
        Properties props = new Properties();
        props.load(new ClassPathResource("application.properties").getInputStream());
        String value = props.getProperty("message");
        if (value!=null) {
            this.message = value;
        }
    }
    public void run(String... args) {
        System.err.println("Hello Embedded " + this.message + "!");
    }
}

@Configuration
@ComponentScan('com.clarabridge.services')
class WebConfiguration {
    
    @Bean
    @Autowired
    public ForeignClass beanName(Service service) {
        return new ForeignClass(service);
    }

}

https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations
    CommonAnnotationBeanPostProcessor
import javax.annotation.PostConstruct;

@Configuration ??? @Component
Exporter {
    @PostConstruct
    public void doPC() {
    }
    @PreDestroy
}

@Autowired, @Inject, @Resource, and @Value annotations are handled by Spring BeanPostProcessor implementations
which in turn means that you cannot apply these annotations within your own BeanPostProcessor or BeanFactoryPostProcessor types (if any).
These types must be 'wired up' explicitly via XML or using a Spring @Bean method.

import org.springframework.beans.factory.annotation.Value;
...
    @Value("${lang.id:en}")
    private String langId;
...

lookup-method (impl will be generated by cglib):

public abstract class CommandManager {
    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}

?MethodReplacer

scopes:
org.springframework.web.context.annotation
@ApplicationScope
@RequestScope
@SessionScope
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-specifying-bean-scope
@Scope("prototype")
    proxyMod (ScopedProxyMode.NO, TARGET_CLASS, INTERFACES)

multiple-wiring-by-type-beans (primary="true")
@Bean @Primary

classpath scanning
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-classpath-scanning

stereotype annotations
@Component
    @Service
    @Controller
    @Repository
    @RestController

component scanning
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-filters
@ComponentScan(
    includeFilters = @Filter(type = FilterType.REGEX, pattern = "..."),
    excludeFilters = ...,
    useDefaultFilters = false
)
    types
    annotation(default)
    assignable
    aspectj
    regex
    custom

bean-metadata within components
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factorybeans-annotations
@Bean
    @Qualifier
    @Scope
    @Lazy

name auto-generation
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-name-generator
    @Service("myMovieLister")
    public class SimpleMovieLister {...}

    @Configuration
    @ComponentScan(basePackages = "org.example", nameGenerator = MyNameGen.class) // MyNameGen impls BeanNameGenerator

custom scope resolver
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-scope-resolver
    @Configuration
    @ComponentScan(basePackages = "org.example", scopeResolver = MyScopeRes.class) // MyScopeRes impls ScopeMetadataResolver

generate an index of candidate components
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-index
    org.springframework.spring-context-indexer
    will generate
        META-INF/spring.components

instantiation
AnnotationConfigApplicationContext
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-instantiating-container
AnnotationConfigWebApplicationContext
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-instantiating-container-web
!!! can be driven by @ComponentScan

@Bean(initMethod="...",
    destroyMethod="..." // close() and shutdown() methods are auto-called !!!
    destroyMethod=""    // to disable this auto-callling behavior
)

@Bean(name="...",
    name={"alias1", "alias2", ...},
    description="...")

@Import(ConfigA.class)
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java-composing-configuration-classes

@Profile({"p1", "!p2"})
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-xml
@Profile("default")
public class DefaultDataConfig {...}

@PropertySource
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-property-source-abstraction
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#propertysource

The @PropertySource annotation provides a convenient and declarative mechanism for adding a PropertySource to Spring’s Environment.
@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {
    @Autowired
    Environment env;
    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
