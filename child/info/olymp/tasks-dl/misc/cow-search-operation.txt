64Mb 2sec

Беси и фермер Джон поехали в город, и Беси потерялась. ФД организовал поиски. Движение идет на мычание Беси. Город организован как дерево. Имеется N (1 <= N <= 100,000) перекрестков, последовательно пронумерованных от 0 до N-1, и N-1 соединяющая их дорога. Поэтому между двумя любыми перекрестками имеется ровно одна дорога. Беси находится на одном из этих N перекрестков.

На каждом перекрестке находится также и участник поисковой партии. ФД может позвонить любому из них, чтобы узнать направление, в котором он слышат мычание (т.е. дорожку из этого перекрестка, по которой нужно двигаться к Беси или что Беси находится на этом перекрестке).

ФД хочет минимизировать количество звонков. Ваша задача - помочь ему в этом, сделав при этом не более чем 20 звонков, Прежде чем определить точно перекресток, на котором находится Беси. В 50% случаев, N будет не более 1000.

Ваша программа должна прочитать карту дерева из файла cowtree.in, а затем взаимодействовать с оценивающей программой через стандартный ввод-вывод (консоль). В каждой строке файла cowtree.in содержится список дорог, исходящих/входящих в данных перекресток. Список пронумерован начиная с 0. Первая строка списка содержит число N. Вторая и последующие строки содержат списки дорожек перекрестка, начиная с перекрестка 0. Первое число K(1 <= K <= N) в каждой строке - это количество дорожек этого перекрестка, далее идут еще K чисел N_0, N_1, ..., N_K-1 - номера перекрестков связанных с этим перекрестком непосредственной дорогой.

Ваша программа должна выводить последовательность перекрестков в стандартный вывод. Как только Вы выведете номер перекрестка, на котором находится Беси, Ваша программа будет остановлена. Это произойдет автоматически. Вам не нужно беспокоиться о том, чтобы сделать это самому.

Кроме того, каждый раз, когда Вы выводите номер перекрестка в стандартный вывод, оценивающая программа сообщает дорожку в направлении Беси. Дорожка будет задаваться номером перекрестка в который нужно двигаться по этой дорожке. Нумерация ведется в порядке ввода из файла cowtree.in, начиная с 0. Вы должны каждый раз читать этот ответ из стандартного ввода.

Если Вы нашли Беси, Ваша программа получит 10 баллов, если Вы сделали не более 20 запросов (включая последний), 0 баллов, если Вы сделали 30 звонков. Иначе Ваше количество баллов будет вычисляться по формуле (30 - количество_звонков).

Для примера рассмотрим случай, когда Беси находится на перекрестке 5 для нижеследующей карты города:


                           Перекресток  Соседи
                0   1            0      1 3
                |   |            1      1 4
             2--3---4--5(B)      2      1 3
                |   |            3      4 0 2 6 4
                6   7            4      4 3 7 1 5
                                 5      1 4
                                 6      1 3
                                 7      1 4
Один из возможных вариантов интерактивной последовательности представлен ниже. Колонка Query показывает данные, выведенные Вашей программой в стандартный вывод, колонка Response описывает данные, получаемые Вашей программой через стандартный ввод, далее следуют комментарии

Query   Response    Location     Neighbor list details
  2        0           3          <3>
  6        0           3          <3>
  3        3           4          0 2 6 <4>
  4        5           5          3 7 1 <5>
  5        нет; программа будет завершена
Из перекрестков 2 и 6, перекресток 3 - ближайший к Беси. Из перекрестка 3 перекресток 4 - ближайший к Беси, из перекрестка 4, перекресток 5 - ближайший к Беси. В перекрестке 5 Беси находится, поэтому получив это число оценивающая программа остановит выполнение Вашей программы.

---------------- Реактивные Программы ----------------------
Для того, чтобы гарантировать, что Ваш вывод не буферируется,
Вы должны делать 'flush' для своего вывода.

Для С/С++

Если Вы используете stdio.h, включите строку
       setbuf(stdout, 0);
в начале выполнения своей программы.

Если  Вы используете потоковый ввод-вывод, пишите так:
cout << line << "\n" << flush;

Для Паскаля,
добавляйте следующий оператор
flush(stdout);
после каждого оператора writeln(line);

Если Ваша программа снята по времени после
вывода ответа, очень возможно, что Вы не делали flush
своему выводу.

Формат ввода

* Строка 1: Одно целое число: N

* Строки 2..N+1: Строка i+1 множество целых чисел, разделенных
                 одиночными пробелами, описывающих
                 перекрестки, соседние с данным. : K, N_1, ..., N_K

Пример ввода (файл cowtree.in):

8
1 3
1 4
1 3
4 0 2 6 4
4 3 7 1 5
1 4
1 3
1 4
